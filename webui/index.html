<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>agent-worker</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600&family=IBM+Plex+Mono:wght@400;600&display=swap"
    />
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <style>
      :root {
        color-scheme: light;
        --bg: #f4f1ea;
        --panel: #fff8ef;
        --ink: #1d1a16;
        --accent: #2a6f97;
        --muted: #75695f;
        --connected: #2d7f4f;
        --connecting: #e89f3c;
        --disconnected: #c44536;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
        background: radial-gradient(circle at top, #fff5e8, #efe3d4 60%);
        color: var(--ink);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
      }
      header {
        padding: 8px 12px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      header h1 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.3px;
      }
      .tag {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        border: 1px solid var(--ink);
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.8px;
        transition: all 0.2s ease;
      }
      main {
        max-width: 100%;
        width: 100%;
        margin: 0;
        padding: 0 8px 8px;
        flex: 1;
        display: flex;
      }
      .panel {
        background: var(--panel);
        border: 2px solid var(--ink);
        box-shadow: 6px 6px 0 var(--ink);
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 100%;
        transition: box-shadow 0.3s ease;
      }
      .toolbar-right {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .tabbar-container {
        overflow-x: auto;
        overflow-y: hidden;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: thin;
        scrollbar-color: var(--muted) transparent;
      }
      .tabbar-container::-webkit-scrollbar {
        height: 6px;
      }
      .tabbar-container::-webkit-scrollbar-track {
        background: transparent;
      }
      .tabbar-container::-webkit-scrollbar-thumb {
        background: var(--muted);
        border-radius: 3px;
      }
      .tabbar {
        display: flex;
        gap: 6px;
        align-items: center;
        min-height: 32px;
      }
      .tab {
        padding: 6px 10px;
        border: 1px solid var(--ink);
        background: #fffdf7;
        cursor: pointer;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        transition: all 0.2s ease;
        white-space: nowrap;
        position: relative;
        user-select: none;
      }
      .tab:hover {
        background: #f5f0e5;
        transform: translateY(-1px);
        box-shadow: 2px 2px 0 var(--ink);
      }
      .tab.active {
        background: var(--ink);
        color: #f7f2ea;
        box-shadow: 4px 4px 0 rgba(29, 26, 22, 0.3);
      }
      .tab.active:hover {
        transform: translateY(0);
      }
      .tab.add {
        border-style: dashed;
        font-weight: 600;
        color: #4a4a4a;
      }
      .tab.add:hover {
        border-style: solid;
        background: var(--accent);
        color: #f7f2ea;
      }
      .tab-label {
        cursor: text;
      }
      .tab-label.editing {
        background: rgba(255, 255, 255, 0.2);
        padding: 2px 4px;
        border-radius: 2px;
        outline: 1px solid currentColor;
      }
      .tab .close {
        border: none;
        background: rgba(0, 0, 0, 0.1);
        color: inherit;
        font-size: 14px;
        padding: 2px 6px;
        cursor: pointer;
        border-radius: 2px;
        transition: all 0.2s ease;
        line-height: 1;
        font-weight: bold;
      }
      .tab .close:hover {
        background: rgba(196, 69, 54, 0.8);
        color: #fff;
        transform: scale(1.1);
      }
      .tab.active .close:hover {
        background: rgba(196, 69, 54, 1);
      }
      button {
        padding: 6px 10px;
        border: 1px solid var(--ink);
        background: var(--accent);
        color: #f7f2ea;
        font-size: 12px;
        font-family: inherit;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
      }
      button:hover {
        background: #23597a;
        transform: translateY(-1px);
        box-shadow: 2px 2px 0 var(--ink);
      }
      button:active {
        transform: translateY(0);
        box-shadow: 1px 1px 0 var(--ink);
      }
      button:focus-visible {
        outline: 2px solid var(--accent);
        outline-offset: 2px;
      }
      .status {
        font-size: 11px;
        color: var(--muted);
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 8px;
        border: 1px solid currentColor;
        border-radius: 2px;
        transition: all 0.3s ease;
      }
      .status::before {
        content: "";
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: currentColor;
        animation: pulse 2s ease-in-out infinite;
      }
      .status.connected {
        color: var(--connected);
        border-color: var(--connected);
      }
      .status.connecting {
        color: var(--connecting);
        border-color: var(--connecting);
      }
      .status.disconnected {
        color: var(--disconnected);
        border-color: var(--disconnected);
      }
      .status.disconnected::before {
        animation: none;
      }
      @keyframes pulse {
        0%, 100% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
      }
      #terminal {
        flex: 1;
        min-height: 600px;
        border: 2px solid var(--ink);
        background: #0c0c0c;
        letter-spacing: 0.2px;
        transition: border-color 0.3s ease;
      }
      #terminal:focus-within {
        border-color: var(--accent);
        box-shadow: 0 0 0 2px rgba(42, 111, 151, 0.2);
      }
      .note {
        font-size: 11px;
        color: var(--muted);
        line-height: 1.4;
      }
      @media (max-width: 960px) {
        header {
          flex-direction: column;
          align-items: flex-start;
          gap: 6px;
          padding: 6px 8px;
        }
        #terminal {
          min-height: 500px;
        }
        .panel {
          box-shadow: 4px 4px 0 var(--ink);
          padding: 8px;
        }
        main {
          padding: 0 4px 4px;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>agent-worker terminal</h1>
      <div class="toolbar-right">
        <button id="reconnect">Reconnect</button>
        <span id="status" class="status disconnected">Disconnected</span>
      </div>
    </header>
    <main>
      <section class="panel">
        <div class="tabbar-container">
          <div id="tabbar" class="tabbar"></div>
        </div>
        <div id="terminal" aria-label="terminal"></div>
        <div class="note">
          The terminal runs inside the container. Attach your config volume to
          access claude code or codex from the shell.
        </div>
      </section>
    </main>
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
    <script>
      const statusLabel = document.getElementById("status");
      const reconnectButton = document.getElementById("reconnect");
      const terminalEl = document.getElementById("terminal");
      const tabbar = document.getElementById("tabbar");

      const terminalTheme = {
        background: "#0c0c0c",
        foreground: "#f7f2ea",
        cursor: "#f7f2ea",
        selection: "#3a2e27",
      };

      const sessions = [];
      let activeSession = null;
      const storageKey = "agent-worker-pty-sessions";
      let saveTimer = null;

      const setStatus = (text, state = 'disconnected') => {
        statusLabel.textContent = text;
        statusLabel.className = 'status ' + state;
      };

      const scheduleSave = () => {
        if (saveTimer) {
          clearTimeout(saveTimer);
        }
        saveTimer = setTimeout(() => {
          const payload = {
            active: activeSession ? activeSession.id : null,
            sessions: sessions.map((session) => ({
              id: session.id,
              name: session.name,
            })),
          };
          localStorage.setItem(storageKey, JSON.stringify(payload));
        }, 200);
      };

      const openSocket = (session, options = {}) => {
        if (activeSession === session) {
          setStatus(`${session.name} connecting...`, 'connecting');
        }
        const protocol = location.protocol === "https:" ? "wss" : "ws";
        const replay = options.replay ? "&replay=1" : "";
        const url =
          protocol +
          "://" +
          location.host +
          `/ws/terminal?cols=${session.term.cols}&rows=${session.term.rows}` +
          `&sessionId=${encodeURIComponent(session.id)}` +
          replay;
        const socket = new WebSocket(url);
        session.socket = socket;

        socket.addEventListener("open", () => {
          if (activeSession === session) {
            setStatus(`${session.name} connected`, 'connected');
          }
          session.term.focus();
        });

        socket.addEventListener("message", (event) => {
          let payload;
          try {
            payload = JSON.parse(event.data);
          } catch (err) {
            return;
          }
          if (payload.type === "session" && payload.id && !session.id) {
            session.id = payload.id;
            scheduleSave();
          }
          if (payload.type === "output") {
            session.term.write(payload.data);
          }
        });

        socket.addEventListener("close", () => {
          if (activeSession === session) {
            setStatus(`${session.name} disconnected`, 'disconnected');
          }
        });

        socket.addEventListener("error", () => {
          if (activeSession === session) {
            setStatus(`${session.name} error`, 'disconnected');
          }
        });
      };

      const openSession = (name, id, options = {}) => {
        const term = new Terminal({
          cursorBlink: true,
          fontSize: 15,
          lineHeight: 1.2,
          fontFamily: '"IBM Plex Mono","JetBrains Mono",monospace',
          theme: terminalTheme,
        });
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        const session = {
          id: id || crypto.randomUUID(),
          name,
          term,
          fitAddon,
          socket: null,
          tab: null,
        };
        sessions.push(session);
        openSocket(session, options);
        term.onData((data) => {
          if (session.socket && session.socket.readyState === WebSocket.OPEN) {
            session.socket.send(JSON.stringify({ type: "input", data }));
          }
        });

        return session;
      };

      const editTabName = (session, labelEl) => {
        const currentName = session.name;
        labelEl.contentEditable = true;
        labelEl.classList.add('editing');
        labelEl.focus();

        const range = document.createRange();
        range.selectNodeContents(labelEl);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);

        const finishEdit = () => {
          labelEl.contentEditable = false;
          labelEl.classList.remove('editing');
          const newName = labelEl.textContent.trim();
          if (newName && newName !== currentName) {
            session.name = newName;
            scheduleSave();
          } else {
            labelEl.textContent = currentName;
          }
        };

        const onKeyDown = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            finishEdit();
            labelEl.removeEventListener('keydown', onKeyDown);
            labelEl.removeEventListener('blur', finishEdit);
          } else if (e.key === 'Escape') {
            labelEl.textContent = currentName;
            labelEl.contentEditable = false;
            labelEl.classList.remove('editing');
            labelEl.removeEventListener('keydown', onKeyDown);
            labelEl.removeEventListener('blur', finishEdit);
          }
        };

        labelEl.addEventListener('keydown', onKeyDown);
        labelEl.addEventListener('blur', finishEdit);
      };

      const renderTabs = () => {
        tabbar.innerHTML = "";
        sessions.forEach((session) => {
          const tab = document.createElement("button");
          tab.className = "tab" + (session === activeSession ? " active" : "");
          const label = document.createElement("span");
          label.className = "tab-label";
          label.textContent = session.name;
          label.addEventListener("dblclick", (event) => {
            event.stopPropagation();
            editTabName(session, label);
          });
          const close = document.createElement("button");
          close.className = "close";
          close.type = "button";
          close.textContent = "Ã—";
          close.addEventListener("click", (event) => {
            event.stopPropagation();
            removeSession(session);
          });
          tab.append(label, close);
          tab.addEventListener("click", (e) => {
            if (e.target !== label) {
              setActiveSession(session);
            }
          });
          session.tab = tab;
          tabbar.appendChild(tab);
        });
        const add = document.createElement("button");
        add.className = "tab add";
        add.textContent = "+ new tty";
        add.addEventListener("click", () => {
          const next = openSession(`tty-${sessions.length + 1}`);
          setActiveSession(next);
        });
        tabbar.appendChild(add);
      };

      const setActiveSession = (session) => {
        if (!session) return;
        activeSession = session;
        terminalEl.innerHTML = "";
        session.term.open(terminalEl);
        session.fitAddon.fit();
        session.term.focus();
        renderTabs();
        scheduleSave();

        // Update status based on connection state
        if (session.socket && session.socket.readyState === WebSocket.OPEN) {
          setStatus(`${session.name} connected`, 'connected');
        } else if (session.socket && session.socket.readyState === WebSocket.CONNECTING) {
          setStatus(`${session.name} connecting...`, 'connecting');
        } else {
          setStatus(`${session.name} disconnected`, 'disconnected');
        }
      };

      const removeSession = (session) => {
        const index = sessions.indexOf(session);
        if (index === -1) return;
        if (session.socket && session.socket.readyState === WebSocket.OPEN) {
          session.socket.send(JSON.stringify({ type: "terminate" }));
          session.socket.close();
        }
        sessions.splice(index, 1);
        scheduleSave();
        if (session === activeSession) {
          const next = sessions[index] || sessions[index - 1];
          if (next) {
            setActiveSession(next);
          } else {
            const fresh = openSession("tty-1");
            setActiveSession(fresh);
          }
        } else {
          renderTabs();
        }
      };

      const resizeActive = () => {
        if (!activeSession) return;
        activeSession.fitAddon.fit();
        if (
          activeSession.socket &&
          activeSession.socket.readyState === WebSocket.OPEN
        ) {
          activeSession.socket.send(
            JSON.stringify({
              type: "resize",
              cols: activeSession.term.cols,
              rows: activeSession.term.rows,
            })
          );
        }
      };

      window.addEventListener("resize", resizeActive);

      reconnectButton.addEventListener("click", () => {
        if (!activeSession) return;
        if (activeSession.socket) {
          activeSession.socket.close();
        }
        openSocket(activeSession);
        setActiveSession(activeSession);
      });

      // Keyboard shortcuts (Ctrl on Windows/Linux, Cmd on Mac)
      document.addEventListener("keydown", (e) => {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const modifier = isMac ? e.metaKey : e.ctrlKey;

        // Ctrl/Cmd+T: New tab
        if (modifier && e.key === 't') {
          e.preventDefault();
          const next = openSession(`tty-${sessions.length + 1}`);
          setActiveSession(next);
        }
        // Ctrl/Cmd+W: Close active tab
        else if (modifier && e.key === 'w') {
          e.preventDefault();
          if (activeSession && sessions.length > 0) {
            removeSession(activeSession);
          }
        }
        // Ctrl/Cmd+Tab: Next tab
        else if (modifier && e.key === 'Tab' && !e.shiftKey) {
          e.preventDefault();
          const index = sessions.indexOf(activeSession);
          const next = sessions[(index + 1) % sessions.length];
          if (next) setActiveSession(next);
        }
        // Ctrl/Cmd+Shift+Tab: Previous tab
        else if (modifier && e.shiftKey && e.key === 'Tab') {
          e.preventDefault();
          const index = sessions.indexOf(activeSession);
          const prev = sessions[(index - 1 + sessions.length) % sessions.length];
          if (prev) setActiveSession(prev);
        }
        // Ctrl/Cmd+1-9: Jump to specific tab
        else if (modifier && e.key >= '1' && e.key <= '9') {
          e.preventDefault();
          const index = parseInt(e.key) - 1;
          if (sessions[index]) {
            setActiveSession(sessions[index]);
          }
        }
      });

      const stored = localStorage.getItem(storageKey);
      if (stored) {
        try {
          const payload = JSON.parse(stored);
          if (Array.isArray(payload.sessions) && payload.sessions.length) {
            payload.sessions.forEach((session) => {
              openSession(session.name, session.id, { replay: true });
            });
            const active =
              sessions.find((session) => session.id === payload.active) ||
              sessions[0];
            setActiveSession(active);
          } else {
            const first = openSession("tty-1");
            setActiveSession(first);
          }
        } catch (err) {
          const first = openSession("tty-1");
          setActiveSession(first);
        }
      } else {
        const first = openSession("tty-1");
        setActiveSession(first);
      }
    </script>
  </body>
</html>
